{"version":3,"file":"queue.js","sourceRoot":"","sources":["../../src/queue.ts"],"names":[],"mappings":"AAMA,MAAM,OAAO,YAAY;IAAzB;QACU,UAAK,GAAG,IAAI,GAAG,EAA2B,CAAC;QAC3C,YAAO,GAAG,IAAI,GAAG,EAAmB,CAAC;IAsC/C,CAAC;IApCQ,OAAO,CAAW,GAAW,EAAE,OAAyB;QAC7D,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;;YACrC,MAAM,IAAI,GAAkB,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC;YACzD,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;gBACvB,MAAA,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,0CAAE,IAAI,CAAC,IAAI,EAAE;aACjC;iBAAM;gBACL,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;aAC7B;YACD,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACpB,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,OAAO,CAAC,GAAW;;QACzB,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;YACzB,OAAO;SACR;QACD,MAAM,IAAI,SAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,0CAAE,KAAK,EAAE,CAAC;QAC1C,IAAI,CAAC,IAAI,EAAE;YACT,OAAO;SACR;QACD,IAAI;YACF,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;YAC5B,IAAI;iBACD,OAAO,EAAE;iBACT,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;iBAClC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;iBAC9B,OAAO,CAAC,GAAG,EAAE;gBACZ,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;gBAC7B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;YACpB,CAAC,CAAC,CAAC;SACN;QAAC,OAAO,KAAK,EAAE;YACd,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACnB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;YAC7B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;SACnB;IACH,CAAC;CACF","sourcesContent":["interface QueuedPromise<T = any> {\n  promise: () => Promise<T>;\n  resolve: (value: T) => void;\n  reject: (reason?: any) => void;\n}\n\nexport class PromiseQueue {\n  private queue = new Map<string, QueuedPromise[]>();\n  private working = new Map<string, boolean>();\n\n  public enqueue<T = void>(key: string, promise: () => Promise<T>): Promise<T> {\n    return new Promise((resolve, reject) => {\n      const item: QueuedPromise = { promise, resolve, reject };\n      if (this.queue.has(key)) {\n        this.queue.get(key)?.push(item);\n      } else {\n        this.queue.set(key, [item]);\n      }\n      this.dequeue(key);\n    });\n  }\n\n  private dequeue(key: string): void {\n    if (this.working.get(key)) {\n      return;\n    }\n    const item = this.queue.get(key)?.shift();\n    if (!item) {\n      return;\n    }\n    try {\n      this.working.set(key, true);\n      item\n        .promise()\n        .then(value => item.resolve(value))\n        .catch(err => item.reject(err))\n        .finally(() => {\n          this.working.set(key, false);\n          this.dequeue(key);\n        });\n    } catch (error) {\n      item.reject(error);\n      this.working.set(key, false);\n      this.dequeue(key);\n    }\n  }\n}\n"]}